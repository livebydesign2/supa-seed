/**
 * Test suite for Template System
 * Phase 4, Checkpoint D3 validation - Template engine, variables, validation, and marketplace
 */

import {
  TemplateEngine,
  Template,
  TemplateVariable,
  RenderResult,
  TemplateEngineOptions
} from '../src/templates/template-engine';

import {
  DynamicVariableResolver,
  VariableResolutionContext,
  ResolutionResult
} from '../src/templates/variable-resolver';

import {
  TemplateValidator,
  ValidationResult,
  TemplateTest,
  TestSuite,
  ValidationRule
} from '../src/templates/template-validator';

import {
  TemplateMarketplace,
  TemplatePackage,
  Repository,
  SearchQuery,
  InstallOptions
} from '../src/templates/template-marketplace';

import { SchemaInfo } from '../src/schema-adapter';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import * as rimraf from 'rimraf';

// Mock Logger
jest.mock('../src/utils/logger', () => ({
  Logger: {
    debug: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn()
  }
}));

describe('Template System', () => {
  let tempDir: string;
  let templateEngine: TemplateEngine;
  let variableResolver: DynamicVariableResolver;
  let templateValidator: TemplateValidator;
  let templateMarketplace: TemplateMarketplace;
  let mockSchema: SchemaInfo;
  let mockTemplate: Template;

  beforeEach(async () => {
    // Create temporary directory for tests
    tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'supa-seed-templates-'));

    // Initialize components
    const engineOptions: TemplateEngineOptions = {
      templateDirectory: path.join(tempDir, 'templates'),
      cacheTemplates: false,
      strictMode: false,
      enableCustomHelpers: true,
      enableHooks: false,
      maxRenderTime: 5000
    };

    templateEngine = new TemplateEngine(engineOptions);
    variableResolver = new DynamicVariableResolver();
    templateValidator = new TemplateValidator(templateEngine, variableResolver);
    templateMarketplace = new TemplateMarketplace(templateEngine, templateValidator, {
      cacheDirectory: path.join(tempDir, 'cache'),
      configDirectory: path.join(tempDir, 'config')
    });

    // Create mock schema
    mockSchema = {
      hasAccounts: false,
      hasUsers: true,
      hasProfiles: true,
      hasSetups: false,
      hasCategories: false,
      hasTeams: false,
      hasOrganizations: false,
      accountsTableStructure: 'simple' as const,
      primaryUserTable: 'users' as const,
      makerkitVersion: 'v3' as const,
      customTables: ['users', 'posts'],
      detectedRelationships: [],
      assetCompatibility: {
        supportsImages: true,
        supportsMarkdown: false,
        supportsJson: true,
        contentTables: ['posts'],
        userContentRelationships: [],
        mediaStoragePattern: 'supabase_storage' as const
      },
      frameworkType: 'makerkit' as const
    };

    // Create mock template
    mockTemplate = {
      id: 'test-seeder-template',
      name: 'Test Seeder Template',
      description: 'A test template for generating seeders',
      version: '1.0.0',
      author: 'Test Author',
      category: 'seeder',
      tags: ['test', 'seeder', 'basic'],
      compatibility: {
        supaSeedVersion: '1.0.0',
        makerKitVersions: ['v1', 'v2', 'v3'],
        supabaseVersions: ['15.x']
      },
      variables: [
        {
          name: 'tableName',
          type: 'string',
          description: 'Name of the table to seed',
          required: true,
          validation: {
            pattern: '^[a-zA-Z][a-zA-Z0-9_]*$',
            minLength: 2,
            maxLength: 50
          },
          prompt: {
            message: 'Enter the table name to seed:',
            hint: 'e.g., users, posts, products'
          }
        },
        {
          name: 'recordCount',
          type: 'number',
          description: 'Number of records to generate',
          required: false,
          defaultValue: 100,
          validation: {
            min: 1,
            max: 10000
          }
        },
        {
          name: 'enableFaker',
          type: 'boolean',
          description: 'Enable Faker.js for realistic data',
          required: false,
          defaultValue: true
        },
        {
          name: 'columns',
          type: 'array',
          description: 'Columns to include in seeding',
          required: false,
          dependencies: ['tableName']
        }
      ],
      files: [
        {
          path: 'seeders/{{snakeCase tableName}}-seeder.ts',
          type: 'handlebars',
          content: `/**\n * {{capitalize tableName}} Seeder\n * Generated by Supa-Seed Template Engine\n */\n\nexport class {{capitalize tableName}}Seeder {\n  async seed() {\n    const records = [];\n    \n    for (let i = 0; i < {{recordCount}}; i++) {\n      records.push({\n        {{#each columns}}\n        {{name}}: {{#if (eq type 'string')}}'{{name}}_' + i{{else}}{{#if (eq type 'number')}}i{{else}}{{#if (eq type 'boolean')}}i % 2 === 0{{else}}null{{/if}}{{/if}}{{/if}},\n        {{/each}}\n      });\n    }\n    \n    return records;\n  }\n}\n\nexport default {{capitalize tableName}}Seeder;`
        },
        {
          path: 'config/{{snakeCase tableName}}-config.json',
          type: 'handlebars',
          content: `{\n  "table": "{{tableName}}",\n  "count": {{recordCount}},\n  "faker": {{json enableFaker}},\n  "columns": {{json columns}}\n}`
        }
      ],
      metadata: {
        created: new Date('2025-01-01'),
        updated: new Date('2025-01-23'),
        downloads: 150,
        rating: 4.5,
        featured: true
      }
    };

    // Ensure template directory exists
    await fs.promises.mkdir(path.join(tempDir, 'templates'), { recursive: true });
  });

  afterEach(async () => {
    // Cleanup temporary directory
    await rimraf.rimraf(tempDir);
  });

  describe('Template Engine', () => {
    test('should initialize with options', () => {
      expect(templateEngine).toBeDefined();
    });

    test('should load template from object', async () => {
      const templateId = await templateEngine.loadTemplate(mockTemplate, false);
      
      expect(templateId).toBe(mockTemplate.id);
      
      const loadedTemplate = templateEngine.getTemplate(templateId);
      expect(loadedTemplate).toEqual(mockTemplate);
    });

    test('should render template with variables', async () => {
      await templateEngine.loadTemplate(mockTemplate, false);
      
      const variables = {
        tableName: 'users',
        recordCount: 50,
        enableFaker: true,
        columns: [
          { name: 'id', type: 'string' },
          { name: 'email', type: 'string' },
          { name: 'age', type: 'number' }
        ]
      };

      const result = await templateEngine.renderTemplate(
        mockTemplate.id,
        variables,
        mockSchema
      );

      expect(result.success).toBe(true);
      expect(result.files).toHaveLength(2);
      expect(result.errors).toHaveLength(0);

      // Check seeder file
      const seederFile = result.files.find(f => f.path.includes('seeder'));
      expect(seederFile).toBeDefined();
      expect(seederFile!.content).toContain('UsersSeeder');
      expect(seederFile!.content).toContain('for (let i = 0; i < 50; i++)');

      // Check config file
      const configFile = result.files.find(f => f.path.includes('config'));
      expect(configFile).toBeDefined();
      expect(configFile!.content).toContain('"table": "users"');
      expect(configFile!.content).toContain('"count": 50');
    });

    test('should handle template with missing variables', async () => {
      await templateEngine.loadTemplate(mockTemplate, false);
      
      const result = await templateEngine.renderTemplate(
        mockTemplate.id,
        {}, // Empty variables
        mockSchema
      );

      expect(result.success).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0].code).toBe('MISSING_REQUIRED_VARIABLE');
    });

    test('should register and use custom helpers', async () => {
      templateEngine.registerHelper('customHelper', (str: string) => `CUSTOM_${str}`);
      
      const customTemplate: Template = {
        ...mockTemplate,
        id: 'custom-helper-test',
        files: [{
          path: 'test.txt',
          type: 'handlebars',
          content: '{{customHelper "test"}}'
        }]
      };

      await templateEngine.loadTemplate(customTemplate, false);
      
      const result = await templateEngine.renderTemplate(
        customTemplate.id,
        { tableName: 'test' }
      );

      expect(result.success).toBe(true);
      expect(result.files[0].content).toBe('CUSTOM_test');
    });

    test('should list templates with filters', () => {
      const templates = templateEngine.listTemplates({
        category: 'seeder',
        tags: ['test']
      });

      expect(Array.isArray(templates)).toBe(true);
    });

    test('should remove template', async () => {
      await templateEngine.loadTemplate(mockTemplate, false);
      
      const removed = templateEngine.removeTemplate(mockTemplate.id);
      expect(removed).toBe(true);
      
      const template = templateEngine.getTemplate(mockTemplate.id);
      expect(template).toBeUndefined();
    });
  });

  describe('Dynamic Variable Resolver', () => {
    test('should resolve variables from multiple sources', async () => {
      const variables: TemplateVariable[] = [
        {
          name: 'tableName',
          type: 'string',
          description: 'Table name',
          required: true
        },
        {
          name: 'tableCount',
          type: 'number',
          description: 'Number of tables',
          required: false
        },
        {
          name: 'nodeEnv',
          type: 'string',
          description: 'Node environment',
          required: false
        }
      ];

      const context: VariableResolutionContext = {
        schema: mockSchema,
        userVariables: {
          tableName: 'posts'
        },
        environment: {
          NODE_ENV: 'test'
        },
        previousResolutions: {},
        metadata: {
          timestamp: new Date(),
          projectPath: tempDir,
          supaSeedVersion: '1.0.0'
        }
      };

      const result = await variableResolver.resolveVariables(variables, context);

      expect(result.success).toBe(true);
      expect(result.resolvedVariables['tableName']).toBeDefined();
      expect(result.resolvedVariables['tableName'].value).toBe('posts');
      expect(result.resolvedVariables['tableName'].source).toBe('user');

      expect(result.resolvedVariables['tableCount']).toBeDefined();
      expect(result.resolvedVariables['tableCount'].value).toBe(2); // From custom tables
      expect(result.resolvedVariables['tableCount'].source).toBe('schema');
    });

    test('should handle variable dependencies', async () => {
      const variables: TemplateVariable[] = [
        {
          name: 'baseUrl',
          type: 'string',
          description: 'Base URL',
          required: true
        },
        {
          name: 'apiEndpoint',
          type: 'string',
          description: 'API endpoint',
          required: false,
          dependencies: ['baseUrl']
        }
      ];

      const context: VariableResolutionContext = {
        userVariables: {
          baseUrl: 'https://example.com'
        },
        environment: {},
        previousResolutions: {},
        metadata: {
          timestamp: new Date(),
          projectPath: tempDir,
          supaSeedVersion: '1.0.0'
        }
      };

      const result = await variableResolver.resolveVariables(variables, context);

      expect(result.success).toBe(true);
      expect(result.resolvedVariables['baseUrl'].value).toBe('https://example.com');
      expect(result.resolvedVariables['apiEndpoint']).toBeDefined();
    });

    test('should add and use custom resolvers', async () => {
      variableResolver.addResolver({
        name: 'custom-test-resolver',
        description: 'Test resolver',
        priority: 99,
        applicableTypes: ['string'],
        resolve: async (variable, context) => {
          if (variable.name === 'customVar') {
            return {
              name: variable.name,
              value: 'custom-resolved-value',
              source: 'computed',
              confidence: 100,
              metadata: {
                resolvedAt: new Date(),
                dependencies: [],
                transformsApplied: []
              }
            };
          }
          return null;
        }
      });

      const variables: TemplateVariable[] = [{
        name: 'customVar',
        type: 'string',
        description: 'Custom variable',
        required: true
      }];

      const context: VariableResolutionContext = {
        userVariables: {},
        environment: {},
        previousResolutions: {},
        metadata: {
          timestamp: new Date(),
          projectPath: tempDir,
          supaSeedVersion: '1.0.0'
        }
      };

      const result = await variableResolver.resolveVariables(variables, context);

      expect(result.success).toBe(true);
      expect(result.resolvedVariables['customVar'].value).toBe('custom-resolved-value');
      expect(result.resolvedVariables['customVar'].source).toBe('computed');
    });

    test('should generate suggestions for unresolved variables', async () => {
      const variables: TemplateVariable[] = [{
        name: 'unknownTable',
        type: 'string',
        description: 'Unknown table',
        required: false
      }];

      const context: VariableResolutionContext = {
        schema: mockSchema,
        userVariables: {},
        environment: {},
        previousResolutions: {},
        metadata: {
          timestamp: new Date(),
          projectPath: tempDir,
          supaSeedVersion: '1.0.0'
        }
      };

      const result = await variableResolver.resolveVariables(variables, context);

      expect(result.suggestions.length).toBeGreaterThan(0);
    });
  });

  describe('Template Validator', () => {
    test('should validate template successfully', async () => {
      const result = await templateValidator.validateTemplate(mockTemplate);

      expect(result.isValid).toBe(true);
      expect(result.score).toBeGreaterThan(80);
      expect(result.summary.errors).toBe(0);
    });

    test('should detect template structure issues', async () => {
      const invalidTemplate: Template = {
        ...mockTemplate,
        id: '', // Invalid empty ID
        name: '', // Invalid empty name
        files: [] // No files
      };

      const result = await templateValidator.validateTemplate(invalidTemplate);

      expect(result.isValid).toBe(false);
      expect(result.summary.errors).toBeGreaterThan(0);
      expect(result.issues.some(i => i.ruleId === 'template_structure')).toBe(true);
    });

    test('should detect variable validation issues', async () => {
      const invalidTemplate: Template = {
        ...mockTemplate,
        variables: [
          {
            name: '123invalid', // Invalid name starting with number
            type: 'string',
            description: '',
            required: true
          },
          {
            name: 'duplicate',
            type: 'string',
            description: 'First duplicate',
            required: false
          },
          {
            name: 'duplicate', // Duplicate name
            type: 'number',
            description: 'Second duplicate',
            required: false
          }
        ]
      };

      const result = await templateValidator.validateTemplate(invalidTemplate);

      expect(result.isValid).toBe(false);
      expect(result.issues.some(i => i.ruleId === 'variable_validation')).toBe(true);
    });

    test('should run template tests', async () => {
      await templateEngine.loadTemplate(mockTemplate, false);

      const test: TemplateTest = {
        id: 'test-basic-render',
        name: 'Basic Render Test',
        description: 'Test basic template rendering',
        templateId: mockTemplate.id,
        variables: {
          tableName: 'users',
          recordCount: 10,
          enableFaker: true,
          columns: [
            { name: 'id', type: 'string' },
            { name: 'name', type: 'string' }
          ]
        },
        expectedFiles: [
          {
            path: 'seeders/users-seeder.ts',
            shouldExist: true,
            contentMatches: 'UsersSeeder',
            minSize: 100
          },
          {
            path: 'config/users-config.json',
            shouldExist: true,
            contentMatches: /"table": "users"/,
            minSize: 50
          }
        ],
        expectedVariables: ['tableName', 'recordCount'],
        shouldSucceed: true,
        timeout: 5000
      };

      const result = await templateValidator.runTest(test, mockSchema);

      expect(result.success).toBe(true);
      expect(result.renderResult?.success).toBe(true);
      expect(result.issues).toHaveLength(0);
    });

    test('should run test suite', async () => {
      await templateEngine.loadTemplate(mockTemplate, false);

      const testSuite: TestSuite = {
        id: 'basic-test-suite',
        name: 'Basic Template Test Suite',
        description: 'Basic tests for template functionality',
        tests: [
          {
            id: 'success-test',
            name: 'Success Test',
            description: 'Should succeed with valid variables',
            templateId: mockTemplate.id,
            variables: {
              tableName: 'users',
              recordCount: 5
            },
            expectedFiles: [
              {
                path: 'seeders/users-seeder.ts',
                shouldExist: true
              }
            ],
            shouldSucceed: true
          },
          {
            id: 'failure-test',
            name: 'Failure Test',
            description: 'Should fail with missing required variables',
            templateId: mockTemplate.id,
            variables: {}, // Missing required tableName
            expectedFiles: [],
            shouldSucceed: false
          }
        ],
        setup: {
          schema: mockSchema
        }
      };

      const result = await templateValidator.runTestSuite(testSuite);

      expect(result.success).toBe(true); // Suite succeeds if tests behave as expected
      expect(result.summary.totalTests).toBe(2);
      expect(result.summary.passed).toBe(2);
      expect(result.summary.failed).toBe(0);
    });

    test('should generate test suite from template', () => {
      const generatedSuite = templateValidator.generateTestSuite(mockTemplate, {
        includeErrorCases: true,
        generateVariableCombinations: false
      });

      expect(generatedSuite.tests.length).toBeGreaterThan(0);
      expect(generatedSuite.tests.some(t => t.shouldSucceed)).toBe(true);
      expect(generatedSuite.tests.some(t => !t.shouldSucceed)).toBe(true);
    });

    test('should add and use custom validation rules', () => {
      const customRule: ValidationRule = {
        id: 'custom-test-rule',
        name: 'Custom Test Rule',
        description: 'A custom rule for testing',
        category: 'structure',
        severity: 'warning',
        validate: (template) => {
          if (template.name.includes('Test')) {
            return [{
              ruleId: 'custom-test-rule',
              severity: 'warning',
              message: 'Template name contains "Test"',
              suggestion: 'Consider using a more descriptive name'
            }];
          }
          return [];
        }
      };

      templateValidator.addValidationRule(customRule);
      
      const rules = templateValidator.getValidationRules();
      expect(rules.some(r => r.id === 'custom-test-rule')).toBe(true);
    });
  });

  describe('Template Marketplace', () => {
    test('should search templates', async () => {
      const query: SearchQuery = {
        query: 'seeder',
        category: 'seeder',
        limit: 10
      };

      const result = await templateMarketplace.search(query);

      expect(result).toBeDefined();
      expect(result.packages).toBeDefined();
      expect(result.total).toBeGreaterThanOrEqual(0);
      expect(result.facets).toBeDefined();
      expect(result.queryTime).toBeGreaterThan(0);
    });

    test('should install template', async () => {
      // First, we need to create a mock template in the local repository
      const templateDir = path.join(tempDir, 'templates');
      await fs.promises.mkdir(templateDir, { recursive: true });
      
      const templateFile = path.join(templateDir, 'test-template.json');
      await fs.promises.writeFile(templateFile, JSON.stringify(mockTemplate, null, 2));

      const options: InstallOptions = {
        skipValidation: true,
        installDependencies: false
      };

      const result = await templateMarketplace.install(mockTemplate.id, options);

      expect(result.success).toBe(true);
      expect(result.template).toBeDefined();
      expect(result.errors).toHaveLength(0);
    });

    test('should handle template not found', async () => {
      const result = await templateMarketplace.install('non-existent-template');

      expect(result.success).toBe(false);
      expect(result.errors).toContain('Template not found: non-existent-template');
    });

    test('should add and remove repositories', async () => {
      const customRepo: Repository = {
        id: 'custom-repo',
        name: 'Custom Repository',
        description: 'A custom test repository',
        url: path.join(tempDir, 'custom-repo'),
        type: 'local',
        config: {
          trustLevel: 'trusted'
        },
        metadata: {
          lastSync: new Date(),
          templateCount: 0,
          enabled: true
        }
      };

      // Create the directory
      await fs.promises.mkdir(customRepo.url, { recursive: true });

      const added = await templateMarketplace.addRepository(customRepo);
      expect(added).toBe(true);

      const repos = templateMarketplace.listRepositories();
      expect(repos.some(r => r.id === 'custom-repo')).toBe(true);

      const removed = await templateMarketplace.removeRepository('custom-repo');
      expect(removed).toBe(true);

      const reposAfterRemoval = templateMarketplace.listRepositories();
      expect(reposAfterRemoval.some(r => r.id === 'custom-repo')).toBe(false);
    });

    test('should sync repositories', async () => {
      const result = await templateMarketplace.syncRepositories();

      expect(result.success).toBeGreaterThanOrEqual(0);
      expect(result.failed).toBeGreaterThanOrEqual(0);
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should clear cache', () => {
      templateMarketplace.clearCache();
      
      // Should not throw error
      expect(true).toBe(true);
    });

    test('should publish template (dry run)', async () => {
      const result = await templateMarketplace.publish(
        mockTemplate,
        'local',
        {
          dryRun: true,
          skipValidation: true
        }
      );

      expect(result.success).toBe(true);
      expect(result.warnings.some(w => w.includes('Dry run'))).toBe(true);
    });
  });

  describe('Integration Tests', () => {
    test('should handle complete template workflow', async () => {
      // 1. Load template
      await templateEngine.loadTemplate(mockTemplate, false);

      // 2. Validate template
      const validation = await templateValidator.validateTemplate(mockTemplate);
      expect(validation.isValid).toBe(true);

      // 3. Resolve variables
      const variables: TemplateVariable[] = mockTemplate.variables;
      const context: VariableResolutionContext = {
        schema: mockSchema,
        userVariables: {
          tableName: 'posts',
          recordCount: 25
        },
        environment: {},
        previousResolutions: {},
        metadata: {
          timestamp: new Date(),
          projectPath: tempDir,
          supaSeedVersion: '1.0.0'
        }
      };

      const resolution = await variableResolver.resolveVariables(variables, context);
      expect(resolution.success).toBe(true);

      // 4. Render template
      const renderVariables: Record<string, any> = {};
      for (const [name, resolved] of Object.entries(resolution.resolvedVariables)) {
        renderVariables[name] = resolved.value;
      }

      const result = await templateEngine.renderTemplate(
        mockTemplate.id,
        renderVariables,
        mockSchema
      );

      expect(result.success).toBe(true);
      expect(result.files.length).toBeGreaterThan(0);

      // 5. Verify generated content
      const seederFile = result.files.find(f => f.path.includes('seeder'));
      expect(seederFile).toBeDefined();
      expect(seederFile!.content).toContain('PostsSeeder');
      expect(seederFile!.content).toContain('25');
    });

    test('should handle template with validation errors', async () => {
      const invalidTemplate: Template = {
        ...mockTemplate,
        id: '',
        variables: [{
          name: 'invalid-name',
          type: 'string',
          description: '',
          required: true
        }]
      };

      // Validation should fail
      const validation = await templateValidator.validateTemplate(invalidTemplate);
      expect(validation.isValid).toBe(false);

      // Installation should be rejected
      const installResult = await templateMarketplace.publish(
        invalidTemplate,
        'local',
        { skipValidation: false }
      );
      expect(installResult.success).toBe(false);
    });

    test('should handle template marketplace search and install flow', async () => {
      // Create template in local repository
      const templateDir = path.join(tempDir, 'templates');
      await fs.promises.mkdir(templateDir, { recursive: true });
      
      const templateFile = path.join(templateDir, 'search-test.json');
      const searchTemplate = {
        ...mockTemplate,
        id: 'search-test-template',
        name: 'Search Test Template'
      };
      await fs.promises.writeFile(templateFile, JSON.stringify(searchTemplate, null, 2));

      // Search for template
      const searchResult = await templateMarketplace.search({
        query: 'Search Test',
        limit: 5
      });

      expect(searchResult.packages.length).toBeGreaterThanOrEqual(0);

      // Install if found
      if (searchResult.packages.length > 0) {
        const installResult = await templateMarketplace.install(
          searchTemplate.id,
          { skipValidation: true }
        );
        expect(installResult.success).toBe(true);
      }
    });

    test('should generate and validate templates from schema', async () => {
      // Generate variables based on schema
      const schemaBasedVariables: TemplateVariable[] = [
        {
          name: 'tables',
          type: 'array',
          description: 'Available tables',
          required: false
        },
        {
          name: 'primaryTable',
          type: 'string',
          description: 'Primary table for seeding',
          required: true
        }
      ];

      const context: VariableResolutionContext = {
        schema: mockSchema,
        userVariables: {},
        environment: {},
        previousResolutions: {},
        metadata: {
          timestamp: new Date(),
          projectPath: tempDir,
          supaSeedVersion: '1.0.0'
        }
      };

      const resolution = await variableResolver.resolveVariables(schemaBasedVariables, context);

      expect(resolution.success).toBe(true);
      expect(resolution.resolvedVariables['tables']).toBeDefined();
      expect(resolution.resolvedVariables['tables'].value).toEqual(['users', 'posts']); // From customTables
    });
  });
});